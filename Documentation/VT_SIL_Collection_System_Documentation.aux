\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\@writefile{toc}{\contentsline {chapter}{Contents}{1}{chapter*.1}}
\@writefile{toc}{\contentsline {chapter}{List of Figures}{2}{chapter*.2}}
\@writefile{toc}{\contentsline {chapter}{\numberline {1}Overview}{3}{chapter.1}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{ch:overview}{{1}{3}{Overview}{chapter.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {1.1}Overview of System Design}{3}{section.1.1}}
\newlabel{sec:overview_of_system_design}{{1.1}{3}{Overview of System Design}{section.1.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {1.2}Overview of Code Flow}{3}{section.1.2}}
\newlabel{sec:overview_of_code_flow}{{1.2}{3}{Overview of Code Flow}{section.1.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.1}{\ignorespaces Collection system design.}}{4}{figure.1.1}}
\newlabel{fig:daq_collection_system_design}{{1.1}{4}{Collection system design}{figure.1.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.2}{\ignorespaces Collection cycle overview: The continuousRawData() stores data to a buffer until a specified timeframe has passed for collection, i.e., the time length of a file. Once this is reached, steps (5) $\rightarrow $ (6) $\rightarrow $ (7) $\rightarrow $ (8) are executed. Here the data is written to file, the buffer is flushed, and then data is collected for the next timeframe.}}{5}{figure.1.2}}
\newlabel{fig:daq_collection_system_code_flow}{{1.2}{5}{Collection cycle overview: The continuousRawData() stores data to a buffer until a specified timeframe has passed for collection, i.e., the time length of a file. Once this is reached, steps (5) $\rightarrow $ (6) $\rightarrow $ (7) $\rightarrow $ (8) are executed. Here the data is written to file, the buffer is flushed, and then data is collected for the next timeframe}{figure.1.2}{}}
\@writefile{toc}{\contentsline {chapter}{\numberline {2}Documentation for each Class}{6}{chapter.2}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{ch:documentation_for_each_class}{{2}{6}{Documentation for each Class}{chapter.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.0.1}main.cpp}{6}{subsection.2.0.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.0.2}DAQ\_Interface.h/cpp}{6}{subsection.2.0.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.0.3}DAQ.h/cpp}{6}{subsection.2.0.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.0.4}Data\_Output.h/cpp}{7}{subsection.2.0.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.0.5}Data\_Output\_Factory.h/Data\_Output\_Factory\_Implementation.h}{7}{subsection.2.0.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.0.6}CSV\_Output.h/cpp}{7}{subsection.2.0.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.0.7}config\_parser.h/cpp}{7}{subsection.2.0.7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.0.8}library.h/cpp}{7}{subsection.2.0.8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.0.9}sensor\_data.h/cpp}{7}{subsection.2.0.9}}
\@writefile{toc}{\contentsline {chapter}{\numberline {3}Hardware}{8}{chapter.3}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{ch:hardware}{{3}{8}{Hardware}{chapter.3}{}}
\@writefile{toc}{\contentsline {chapter}{\numberline {4}Software}{9}{chapter.4}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{ch:software}{{4}{9}{Software}{chapter.4}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.1}Data Pipeline}{9}{section.4.1}}
\newlabel{sec:data_pipeline}{{4.1}{9}{Data Pipeline}{section.4.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.2}Configuration File}{10}{section.4.2}}
\newlabel{sec:config_file}{{4.2}{10}{Configuration File}{section.4.2}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.3}Parameters and Data Structures}{11}{section.4.3}}
\newlabel{sec:parameters_and_data_structures}{{4.3}{11}{Parameters and Data Structures}{section.4.3}{}}
\@writefile{lot}{\contentsline {table}{\numberline {4.1}{\ignorespaces Example calculation of the time of each sample in a file. Note: n is the last line in the file.}}{13}{table.4.1}}
\newlabel{tab:booktabs}{{4.1}{13}{Example calculation of the time of each sample in a file. Note: n is the last line in the file}{table.4.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.4}Setting up Development Environment}{13}{section.4.4}}
\newlabel{sec:setting_up_development_environment}{{4.4}{13}{Setting up Development Environment}{section.4.4}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.5}Software Versioning}{13}{section.4.5}}
\newlabel{sec:software_versioning}{{4.5}{13}{Software Versioning}{section.4.5}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.1}{\ignorespaces Example of how versioning works. One starts with a \emph  {master} version of the code. Then a \emph  {working development} branch is created for development. When a new feature wants to be tested, a new branch is created (\emph  {cool feature 1}). When the operation of the feature is satisfactory, that code is merged back into the \emph  {working development}. When the \emph  {working development} is stable, it is merged back into \emph  {master}. }}{14}{figure.4.1}}
\newlabel{fig:version_control_flow}{{4.1}{14}{Example of how versioning works. One starts with a \emph {master} version of the code. Then a \emph {working development} branch is created for development. When a new feature wants to be tested, a new branch is created (\emph {cool feature 1}). When the operation of the feature is satisfactory, that code is merged back into the \emph {working development}. When the \emph {working development} is stable, it is merged back into \emph {master}}{figure.4.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.6}Code Base and Github}{14}{section.4.6}}
\newlabel{sec:code_base}{{4.6}{14}{Code Base and Github}{section.4.6}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.7}Running the System}{15}{section.4.7}}
\newlabel{sec:running_the_system}{{4.7}{15}{Running the System}{section.4.7}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.8}Technical Details}{16}{section.4.8}}
\newlabel{sec:technical_details}{{4.8}{16}{Technical Details}{section.4.8}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.9}Challenges and Solutions}{17}{section.4.9}}
\newlabel{sec:challenges_and_solutions}{{4.9}{17}{Challenges and Solutions}{section.4.9}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.9.1}DAQ Buffer Filling Up}{17}{subsection.4.9.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.9.2}Slow-down in Windows 8.1}{18}{subsection.4.9.2}}
\newlabel{sec:slow_down_in_windows_8_1}{{4.9.2}{18}{Slow-down in Windows 8.1}{subsection.4.9.2}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.10}Data Storage}{18}{section.4.10}}
\newlabel{sec:data_storage}{{4.10}{18}{Data Storage}{section.4.10}{}}
\@writefile{toc}{\contentsline {chapter}{\numberline {5}Currently Known Problems}{19}{chapter.5}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{ch:currently_known_problems}{{5}{19}{Currently Known Problems}{chapter.5}{}}
\@writefile{toc}{\contentsline {chapter}{\numberline {A}Github Reference Sheet}{20}{appendix.A}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{appendix_github_reference_sheet}{{A}{20}{Github Reference Sheet}{appendix.A}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {A.1}{\ignorespaces Github reference sheet (page 1).}}{21}{figure.A.1}}
\newlabel{fig:github_reference_sheet_page_2}{{A.1}{21}{Github reference sheet (page 1)}{figure.A.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {A.2}{\ignorespaces Github reference sheet (page 2).}}{22}{figure.A.2}}
\newlabel{fig:github_reference_sheet_page_2}{{A.2}{22}{Github reference sheet (page 2)}{figure.A.2}{}}
